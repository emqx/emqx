name: Run test case

on:
  push:
    tags:
      - v*
      - e*
    branches:
      - 'main-v4.[0-9]?'
  pull_request:

jobs:
  prepare:
    runs-on: aws-amd64
    container: ghcr.io/emqx/emqx-builder/4.4-20:24.3.4.2-1-ubuntu20.04
    outputs:
      fast_ct_apps: ${{ steps.run_find_apps.outputs.fast_ct_apps }}
      docker_ct_apps: ${{ steps.run_find_apps.outputs.docker_ct_apps }}
    steps:
      - uses: AutoModality/action-clean@v1
      - uses: actions/checkout@v3
        with:
          path: source
          fetch-depth: 0
      - name: git credentials
        if: endsWith(github.repository, 'emqx-enterprise')
        run: |
          echo "https://ci%40emqx.io:${{ secrets.CI_GIT_TOKEN }}@github.com" > $HOME/.git-credentials
          git config --global credential.helper store
      - name: find_ct_apps
        working-directory: source
        id: run_find_apps
        # emqx_plugin_libs doesn't have a test suite -> excluded from app list
        # emqx ct is run independently -> exclude it from the app list (regular ct)
        # lib-ee/emqx_node_rebalance -> exclude it from app list (regular ct)
        run: |
          fast_ct_apps="$(./scripts/find-apps.sh --ct fast --json)"
          docker_ct_apps="$(./scripts/find-apps.sh --ct docker --json)"
          echo "fast_ct_apps=$fast_ct_apps" | tee -a $GITHUB_OUTPUT
          echo "docker_ct_apps=$docker_ct_apps" | tee -a $GITHUB_OUTPUT
      - name: get_all_deps
        working-directory: source
        run: |
          git config --global --add safe.directory $(pwd)
          # build the default profile for two purposes
          # 1. download all dependencies (so the individual app runs do not depend on github credentials)
          # 2. some of the files such as segmented config files are not created when compiling only the test profile
          make
          # compile test profile to speed up the individual runs
          ./rebar3 as test compile
          cd ..
          zip -ryq source.zip source/* source/.[^.]*
      - uses: actions/upload-artifact@v3
        with:
          name: source
          path: source.zip

  eunit_and_proper:
    needs: prepare
    runs-on: aws-amd64
    container: ghcr.io/emqx/emqx-builder/4.4-20:24.3.4.2-1-ubuntu20.04
    strategy:
      fail-fast: false
      matrix:
        task:
          - eunit
          - proper
    steps:
      - uses: AutoModality/action-clean@v1
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: .
      - name: unzip source code
        run: unzip -o -q source.zip
      # produces eunit.coverdata and proper.coverdata
      - name: eunit and proper
        working-directory: source
        run: make ${{ matrix.task }}
      - uses: actions/upload-artifact@v3
        with:
          name: cover
          path: source/_build/test/cover
          if-no-files-found: warn

  fast_ct:
    needs: prepare
    runs-on: ${{ matrix.runs-on }}
    container: ghcr.io/emqx/emqx-builder/4.4-20:24.3.4.2-1-ubuntu20.04
    strategy:
      fail-fast: false
      matrix:
        app_name: ${{ fromJson(needs.prepare.outputs.fast_ct_apps) }}
        runs-on:
          - aws-amd64
          - ubuntu-20.04
        use-self-hosted:
          - ${{ github.repository_owner == 'emqx' }}
        exclude:
          - runs-on: ubuntu-20.04
            use-self-hosted: true
          - runs-on: aws-amd64
            use-self-hosted: false
    steps:
      - uses: AutoModality/action-clean@v1
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: .
      - name: unzip source code
        run: unzip -o -q source.zip
      # produces emqx-<appname>.coverdata
      - name: make-app-ct-pipeline
        working-directory: source
        run: |
          export CT_READABLE=true
          make ${{ matrix.app_name }}-ct-pipeline
      - uses: actions/upload-artifact@v3
        with:
          name: cover
          path: source/_build/test/cover
          if-no-files-found: warn

  docker_ct:
    needs: prepare
    runs-on: ${{ matrix.runs-on }}
    strategy:
      max-parallel: 12
      fail-fast: false
      matrix:
        app_name: ${{ fromJson(needs.prepare.outputs.docker_ct_apps) }}
        runs-on:
          - aws-amd64
          - ubuntu-20.04
        use-self-hosted:
          - ${{ github.repository_owner == 'emqx' }}
        exclude:
          - runs-on: ubuntu-20.04
            use-self-hosted: true
          - runs-on: aws-amd64
            use-self-hosted: false
    steps:
      - uses: AutoModality/action-clean@v1
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: .
      - name: unzip source code
        run: unzip -q source.zip
        # to avoid dirty self-hosted runners
      - name: stop containers
        run: |
          docker rm -f $(docker ps -qa) || true
          docker network rm $(docker network ls -q) || true
          docker system prune --volumes -f
      - name: docker compose up
        working-directory: source
        env:
          MYSQL_TAG: 8
          REDIS_TAG: 6
          MONGO_TAG: 4
          PGSQL_TAG: 13
          LDAP_TAG: 2.4.50
          OPENTSDB_TAG: latest
          INFLUXDB_TAG: 1.7.6
          DYNAMODB_TAG: 1.11.477
          TIMESCALE_TAG: latest-pg11
          CASSANDRA_TAG: 3.11.6
          RABBITMQ_TAG: 3.7
          KAFKA_TAG: 2.5.0
          PULSAR_TAG: 2.3.2
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        timeout-minutes: 40
        run: |
          ulimit -n
          docker_compose_files="\
              -f .ci/docker-compose-file/docker-compose.yaml \
              -f .ci/docker-compose-file/docker-compose-toxiproxy.yaml \
              -f .ci/docker-compose-file/docker-compose-mongo-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-mysql-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-pgsql-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-redis-single-tcp.yaml"
          ee_docker_compose_files="\
              -f .ci/docker-compose-file/docker-compose-enterprise.yaml \
              -f .ci/docker-compose-file/docker-compose-mongo-replicaset-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-mongo-sharded-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-cassandra-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-dynamodb-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-influxdb-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-kafka-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-opentsdb-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-pulsar-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-rabbit-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-timescale-tcp.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-mysql-client.yaml \
              -f .ci/docker-compose-file/docker-compose-enterprise-pgsql-and-timescale-client.yaml"
          if [ -f EMQX_ENTERPRISE ]; then
            docker_compose_files="${docker_compose_files} ${ee_docker_compose_files}"
          fi
          # only build ldap docker image when necessary, it takes 9 minutes
          if [[ ${{ matrix.app_name }} == *ldap ]]; then
            docker_compose_files="${docker_compose_files} -f .ci/docker-compose-file/docker-compose-ldap-tcp.yaml"
          fi
          docker-compose $docker_compose_files up -d --build
          if [ -f EMQX_ENTERPRISE ]; then
            docker exec -i erlang bash -c "echo \"https://ci%40emqx.io:${{ secrets.CI_GIT_TOKEN }}@github.com\" > /root/.git-credentials && git config --global credential.helper store"
          fi
          docker exec -i erlang bash -c "git config --global --add safe.directory /emqx"
          clients="$(docker ps -q --filter name=client)"
          for client in ${clients}; do
            docker ps -a --filter name=client
            echo "waiting for docker ${client} to exit"
            if ! timeout 60 docker wait "${client}"; then
              docker-compose $docker_compose_files logs | tee docker-compose.log
              exit 1
            fi
          done
      - name: run common test
        run: docker exec -i erlang bash -c "env CT_READABLE=true make ${{ matrix.app_name }}-ct-pipeline"
      - name: cat rebar.crashdump
        if: failure()
        working-directory: source
        run: if [ -f 'rebar3.crashdump' ];then cat 'rebar3.crashdump'; fi
      - name: set log file name
        if: failure()
        run: echo "LOGFILENAME=logs-$(echo ${{ matrix.app_name }} | tr '/' '_')" >> $GITHUB_ENV
      - name: stop containers
        run: |
          docker rm -f $(docker ps -qa) || true
          docker network rm $(docker network ls -q) || true
          docker system prune --volumes -f
      - uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: ${{ env.LOGFILENAME }}
          path: |
            docker-compose.log
            source/_build/test/logs
          if-no-files-found: warn
      - uses: actions/upload-artifact@v3
        with:
          name: cover
          path: source/_build/test/cover
          if-no-files-found: warn

  make_cover:
    needs:
      - eunit_and_proper
      - fast_ct
      - docker_ct
    runs-on: aws-amd64
    container: ghcr.io/emqx/emqx-builder/4.4-20:24.3.4.2-1-ubuntu20.04
    steps:
      - uses: AutoModality/action-clean@v1
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: .
      - name: unzip source code
        run: unzip -q source.zip
      - uses: actions/download-artifact@v3
        name: download cover data
        with:
          name: cover
          path: source/_build/test/cover
      - name: make cover
        working-directory: source
        run: make cover
      - name: send to coveralls
        working-directory: source
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: make coveralls
      - name: get coveralls logs
        working-directory: source
        if: failure()
        run: cat rebar3.crashdump

  finish:
    needs: make_cover
    runs-on: aws-amd64
    steps:
      - name: Coveralls Finished
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          curl -v -k https://coveralls.io/webhook \
               --header "Content-Type: application/json" \
               --data "{\"repo_name\":\"$GITHUB_REPOSITORY\",\"repo_token\":\"$GITHUB_TOKEN\",\"payload\":{\"build_num\":$GITHUB_RUN_ID,\"status\":\"done\"}}" || true
